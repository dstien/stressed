// stressed - Stunts/4D [Sports] Driving resource editor
// Copyright (C) 2008 Daniel Stien <daniel@stien.org>
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

#include <QGLWidget>
#include <QPaintEvent>

#include "materialsmodel.h"
#include "shapemodel.h"
#include "shapeview.h"
#include "verticesmodel.h"

const quint8 ShapeView::PATTERNS[5][0x80] = {
  { // Grate
    0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
    0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
    0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
    0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
    0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
    0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
    0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
    0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC
  },
  { // Grille
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F
  },
  { // Inverse grille
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0
  },
  { // Glass
    0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF,
    0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF,
    0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF,
    0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF,
    0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF,
    0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF,
    0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF,
    0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0xF3, 0x3C, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF, 0x3C, 0xCF
  },
  { // Inverse glass
    0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30,
    0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30,
    0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30,
    0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30,
    0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30,
    0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30,
    0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30,
    0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0x0C, 0xC3, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30
  }
};

ShapeView::ShapeView(QWidget* parent)
: QAbstractItemView(parent)
{
  currentPaintJob = 0;
  transform = Matrix();

  glWidget = new QGLWidget(this);
  glWidget->makeCurrent();
  glWidget->qglClearColor(Qt::white);

  glEnable(GL_DEPTH_TEST);
  glDisable(GL_CULL_FACE);

  setViewport(glWidget);
}

void ShapeView::setModel(QAbstractItemModel* model)
{
  ShapeModel* shapeModel = qobject_cast<ShapeModel*>(model);

  if (shapeModel) {
    transform.move(-((shapeModel->boundBox()[4].y + shapeModel->boundBox()[0].y) / 2), Matrix::AXIS_Y);
    transform.move(shapeModel->boundBox()[2].z * 2, Matrix::AXIS_Z);
//    transform.rotate(45.0f, Matrix::AXIS_Y);
    transform.rotate(10.0f, Matrix::AXIS_X);
//    transform.rotate(10.0f, Matrix::AXIS_Z);
  }

  QAbstractItemView::setModel(model);
}

void ShapeView::setCurrentPaintJob(int paintJob)
{
  currentPaintJob = qMax(0, paintJob - 1);
  viewport()->update();
}

void ShapeView::toggleWireframe(bool enable)
{
  glPolygonMode(GL_FRONT_AND_BACK, (enable ? GL_LINE : GL_FILL));
  viewport()->update();
}

void ShapeView::toggleCulling(bool enable)
{
  if (enable) {
    glEnable(GL_CULL_FACE);
  }
  else {
    glDisable(GL_CULL_FACE);
  }

  viewport()->update();
}

void ShapeView::updateGeometries()
{
  int width = viewport()->width();
  int height = qMax(1, viewport()->height());

  glWidget->makeCurrent();
  glViewport(0, 0, width, height);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(45.0f, (GLfloat)width / (GLfloat)height, 0.1f, 5000.0f);

  glMatrixMode(GL_MODELVIEW);

  QAbstractItemView::updateGeometries();
}

void ShapeView::showEvent(QShowEvent* event)
{
  glWidget->makeCurrent();
  QAbstractItemView::showEvent(event);
}

void ShapeView::paintEvent(QPaintEvent* event)
{
  event->accept();
  ShapeModel* shapeModel = qobject_cast<ShapeModel*>(model());

  if (!shapeModel) {
    return;
  }

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glLoadIdentity();

  glPushMatrix();
  transform.multMatrix();

  int i = 0;
  QItemSelectionModel* selections = selectionModel();

  foreach (Primitive primitive, *shapeModel->primitivesList()) {
    VerticesList* verticesList = primitive.verticesModel->verticesList();
    MaterialsList* materialsList = primitive.materialsModel->materialsList();

    int material = materialsList->at(currentPaintJob);
    QColor color = palette()[materials()[material].color];

    if (selections->isSelected(shapeModel->index(i, 0))) {
      color.setRed(qMin(0xFF, color.red() + 0x7F));
      color.setGreen(qMax(0, color.green() - 0x7F));
      color.setBlue(qMax(0, color.blue() - 0x7F));
    }

    glWidget->qglColor(color);

    if (materials()[material].pattern && (materials()[material].pattern <= 6)) {
      if (materials()[material].pattern == 1) { // Skip transparent primitives.
        continue;
      }

      glEnable(GL_POLYGON_STIPPLE);
      glPolygonStipple(PATTERNS[materials()[material].pattern - 2]);
    }

    if (primitive.depthIndex) {
      glPolygonOffset(-1.0f, -primitive.depthIndex);
      glEnable(GL_POLYGON_OFFSET_POINT);
      glEnable(GL_POLYGON_OFFSET_LINE);
      glEnable(GL_POLYGON_OFFSET_FILL);
    }

    // Particle.
    if (primitive.type == 1) {
      glBegin(GL_POINT);
      glVertex3s(verticesList->at(0).x, verticesList->at(0).y, verticesList->at(0).z);
      glEnd();
    }
    // Line.
    else if (primitive.type == 2) {
      glBegin(GL_LINES);
      foreach (Vertex vertex, *verticesList) {
        glVertex3s(vertex.x, vertex.y, vertex.z);
      }
      glEnd();
    }
    // Polygon.
    else if (primitive.type > 2 && primitive.type < 11) {
      glBegin(GL_POLYGON);
      // Draw polygons backwards due to the flipped Z-axis.
      for (int i = verticesList->size(); i > 0; i--) {
        Vertex vertex = verticesList->at(i - 1);
        glVertex3s(vertex.x, vertex.y, vertex.z);
      }
      glEnd();
    }
    // Sphere/wheel.
    else if (primitive.type == 11 | primitive.type == 12) {
      glBegin(GL_LINE_STRIP);
      foreach (Vertex vertex, *verticesList) {
        glVertex3s(vertex.x, vertex.y, vertex.z);
      }
      glEnd();
    }

    if (materials()[material].pattern) {
      glDisable(GL_POLYGON_STIPPLE);
    }

    if (primitive.depthIndex) {
      glDisable(GL_POLYGON_OFFSET_POINT);
      glDisable(GL_POLYGON_OFFSET_LINE);
      glDisable(GL_POLYGON_OFFSET_FILL);
      glPolygonOffset(0.0f, 0.0f);
    }

    i++;
  }

  glPopMatrix();

  glWidget->swapBuffers();
}

void ShapeView::mousePressEvent(QMouseEvent* event)
{
  event->accept();
  lastMousePosition = event->pos();
}

void ShapeView::mouseMoveEvent(QMouseEvent* event)
{
  event->accept();
  QPoint delta = event->pos() - lastMousePosition;
  lastMousePosition = event->pos();

  if (event->buttons() & Qt::LeftButton) {
    transform.rotate(-delta.x() * 0.25f, Matrix::AXIS_Y);
    transform.rotate(-delta.y() * 0.25f, Matrix::AXIS_X);
  }
  else if (event->buttons() & Qt::RightButton) {
    transform.rotate(delta.x() * 0.25f, Matrix::AXIS_Z);
  }
  else if (event->buttons() & Qt::MidButton) {
    transform.move(delta.y() * 10.0f, Matrix::AXIS_Z);
    transform.move(delta.x() * 10.0f, Matrix::AXIS_X);
  }

  viewport()->update();
}

Palette ShapeView::palette()
{
  static Palette pal = Settings().getPalette("palettes/vga");
  return pal;
}

Materials ShapeView::materials()
{
  static Materials mat = Settings().getMaterials();
  return mat;
}
